@use 'sass:list';
@use 'sass:map';
@use 'sass:meta';
@use 'sass:selector';
@use 'sass:string';
@use 'config';
@use 'size';
@use 'mixins';

$default-prefix: 'u-';
$default-override: '';
$default-delimiter: '-';
$default-variant-delimiter: '\\:';

// ALL WIP
/*
    Main utility for generating utility classes with different viewports, delimiters, base class names, etc.
    Example: .sm\:hover\:u-text-blue:hover { ... }

    @class-prefix {string} [$default-prefix] - prefix used for generated classes. This is the first section of the class name
    @delimiter {string} [$default-delimiter] - delimiter used in class name body but not for separating psuedos
    @base-class-name {string} - the root of the class name. For the utility class above, 'blue' is the base class name
    @class-value-pairs {map<string, any>[]} - list of mappings that maps the variant name (e.g. 'blue') to a map of CSS properties to values
    @variants {string[]} [()] - list of strings specifying which variants to generate styles for
    @variant-delimiter {string} [$default-variant-delimiter] - delimiter used to separate the variant portion of the class
    @generate-viewports {boolean} [false] - flag to indicate if we should generate classes with different viewports
    @override {string} [$default-override] - override for CSS properties, like '!important'
*/
@mixin utility(
    $class-prefix: $default-prefix,
    $delimiter: $default-delimiter,
    $base-class-name,
    $class-value-pairs,
    $variants: (),
    $variant-delimiter: $default-variant-delimiter,
    $generate-viewports: false,
    $override: $default-override
) {
    $context: (
        'delimiter': $delimiter,
        'variant-delimiter': $variant-delimiter
    );
    @include generate-rules-pseudos-selectors($variants: $variants, $context: $context, $generate-viewports: $generate-viewports) using
        ($props...) {
        #{$base-class-name} {
            @include kv-class-generator($class-value-pairs, $props...) using ($value) {
                @include mixins.explode-properties($value, $override);
            }
        }
    }
}

@mixin generate-rules-pseudos-selectors($variants: (), $context: (), $generate-viewports: false) {
    $rules: (); // Media queries, after responsive classes
    $pseudos: (); // Selectors like :focus

    @if $generate-viewports {
        $rules: map.set($rules, 'responsive', get-responsive());
    }

    // Iterate over all variants and split between rules and pseudos
    @each $variant in $variants {
        // Check for get-rules
        @if meta.function-exists('get-#{$variant}') {
            $func: meta.get-function('get-#{$variant}');
            $rule-map: meta.call($func);
            $rules: map.set($rules, $variant, $rule-map); // ( 'dark': '@media (prefers-color-scheme: dark)',)
        } @else {
            $pseudos: list.append($pseudos, $variant);
        }
    }

    // Generate classes without rules
    @include generate-variants($pseudos, $context) using ($props...) {
        @content ($props...);
    }

    // Generate with rules
    // Rules for responsiveness and light/dark mode are roots of separate classes, they never appear together
    @each $rule in map.values($rules) {
        @each $key, $value in $rule {
            $current-context: map.merge(
                $context,
                (
                    rule: $key,
                )
            );

            @if string.index($value, '@media') {
                $value: string.slice($value, 7);

                @media #{$value} {
                    @include generate-variants($pseudos, $current-context) using ($props...) {
                        @content ($props...);
                    }
                }
            }
        }
    }
}

@mixin generate-variants($variants: (), $context: ()) {
    // Get classes without pseudos, only rules
    @if & {
        @include get-base-class($context...) {
            @content;
        }

        @each $variant in $variants {
            $current-context: map.merge(
                $context,
                (
                    variant: $variant,
                    pseudo: $variant,
                )
            );
            @if string.index($variant, 'group-') {
                $current-context: map.merge(
                    $current-context,
                    (
                        pseudo: string.slice($variant, 7),
                        scope: '.group',
                    )
                );
            }

            @include get-base-class($current-context...) {
                @content;
            }
        }
    } @else {
        @content ($variants, $context);
    }
}

@mixin get-base-class($context...) {
    $base: ();

    @each $selector in & {
        $selector: list.nth($selector, 1);

        @if meta.type-of($selector) == 'string' {
            $selector: string.slice($selector, 1);
        }

        @if $selector {
            $base: list.append($base, $selector, comma);
        }
    }

    @at-root {
        @include generate-class($base, $context...) {
            @content;
        }
    }
}

@mixin generate-class($base, $delimiter, $variant-delimiter, $rule: null, $variant: null, $pseudo: null, $scope: null) {
    @if $variant {
        $base: selector.append('#{$variant}#{$variant-delimiter}', $base);
    }
    @if $rule {
        $base: selector.append('#{$rule}#{$variant-delimiter}', $base);
    }

    @if $scope and $pseudo {
        // For group related variants (e.g. .group:hover)
        $parent-selector: selector.append($scope, ':#{$pseudo}');
        $base: selector.nest($parent-selector, string-to-class($base)); // Nest class below the parent selector
    } @else if $scope {
        // Contains parent selector
        $base: selector.nest($scope, string-to-class($base));
    } @else if $pseudo {
        // Contains pseudo
        $base: selector.append(string-to-class($base), ':#{$pseudo}');
    } @else {
        // Contains nothing
        $base: string-to-class($base);
    }

    // Generate the class
    #{$base} {
        @content;
    }
}

@mixin kv-class-generator($class-value-pairs: (), $variants: (), $context: ()) {
    @if & {
        @each $key, $value in $class-value-pairs {
            &#{map.get($context, 'delimiter')}#{$key} {
                @include generate-rules-pseudos-selectors($variants, $context) {
                    @content ($value);
                }
            }
        }
    } @else {
        @include generate-rules-pseudos-selectors($variants, $context) using ($props...) {
            @each $key, $value in $class-value-pairs {
                .#{$key} {
                    @include generate-rules-pseudos-selectors($variants, $context) {
                        @content ($value);
                    }
                }
            }
        }
    }
}

@function get-responsive() {
    $result: ();

    @each $key, $value in config.$breakpoint-pairs {
        $result: map.set($result, $key, '@media (min-width: #{map-get(config.$breakpoints, $value)})');
    }

    @return $result;
}

@function get-dark() {
    @return ('dark': '@media (prefers-color-scheme: dark)');
}

@function get-light() {
    @return ('light': '@media (prefers-color-scheme: light)');
}

@function get-reduce-motion() {
    @return ('reduce-motion': '@media (prefers-reduced-motion: reduce)');
}

@function class-value-map-with-single-property($property, $property-values) {
    $result: ();

    @each $key, $value in $property-values {
        $result: map.set(
            $result,
            $key,
            (
                $property: $value,
            )
        );
    }

    @return $result;
}

/**
    * Convert a string to a proper class selector.
    * @param: {String}  $selector
    * @return: {Selector}  Returns the class selector.
    */
@function string-to-class($selector) {
    $separator: list.separator($selector);
    $result: ();

    @each $s in $selector {
        @if $s != '' {
            $result: list.append($result, '.#{$s}', $separator);
        }
    }
    @return $result;
}
